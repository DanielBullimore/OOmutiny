//Javascript Document
//Copyright 2019 Daniel Bullimore
//* File Name: O.class.js
//* System: OOmutiny
//* Dependencies: <Name any files this one requires to operate correctly>
//****************************************************************************************************** 	
//* Author:        Daniel Bullimore
//* Authors email: daniel.k.bullimore@gmail.com
//* Written:       31/12/2019
//******************************************************************************************************
//* !---If you modify this file, add your name to this then update the Last Modified date---!
//* Modifications By: <name1>, <name2>, â€¦ , <Your Name>
//* Last Modified:      <Date dd/mm/yyyy>
//******************************************************************************************************
//*
//*
//******************************************************************************************************
//* DESCRIPTION
//******************************************************************************************************
/*
Stable Loop, executes queued interrupts between drawing the "world".
Drawing the world involves redrawing all the rendered objects to synchronize their GUI state with their
programmatic states. Interrupts are generated by events and are intended to ether act(small immediate
animations) or solve(change a instances properties). I envision the loop + interrupt relationship 
working like an appointment book, except the book is kept by the sun at the center of a solar system.

*That suns line of sight is static

*The sun only sees interrupts by appointment, but they must be on time

*Each page of an appoint book is normally divided into denominated appointment slots.For our sun those
slots are its planets

*More than one Interrupt can queue on a single planet appointment slot

*Interrupts can not queue on the planet furthest from the sun, that slot draws the world

*The planets distances from the sun is determined by a benchmark run before the sun ever existed

*Each time a planet crosses the suns line of sight, the sun executes one interrupt.

*A solar year ends when the most distant planet crosses the suns line of sight it redraws the world(one frame)

As a result the sun can now deal with one off interrupts on a priority basses.A four planet solar system
  will see its closest planet 4 times before it sees its most distant planet once(complete iteration of the
  stable loop).Highest priority interrupts go on the closest planet and lower priority on more distant ones.
  As a cool side effect an HID interrupt on planet 1 might set an interrupt on planet 2 which could be 
  executed before the solar year ends.It also allows 3 intensity settings  for high frequency repeating interrupts.

So what I 'm trying to do here is remove the time in exact milliseconds
  from the framework. The number of milliseconds each iteration of the game
  loop takes is dynamic per machine it benchmarks. So developers 
  implementing my OoMutiny framework couldn't book an interrupt in 67 
  milliseconds if a benchmark determined a 1000 millisecond loop because it
  wouldn 't ever be executed. However if we benchmark two machines A and B.
  A scored 1000ms solar year (complete loop, 1 frame), B scored 400ms. 
  Then we divide those scores by three to get the first planets cycles per
  solar year, divide by 4 to get planet 2, 7 for planet 3...
  Thus our developers can book an interrupt in "Cycles"
  on both machines confident that it will be executed in a timely and 
  graceful fashion regardless of an individual client machines computing power.
  Real time can be derived in a Cycles per second benchmark.
  
This one system quickly provides:

  *Prioritization of immediate interrupts
  *Intensity of high frequency interrupts
  *scaled time critical interrupts over multi solar year runs
  *Performance tailored to each client.

Properties:
  numBenchmarkSolarYear - Protected number, interval in milliseconds between drawing each frame.(one solar year)
  numCyclesPerSecond - private number, derived value, effectively frames per second.Used to calculate realtime.
  rayMecury - public array, highest priority appointment slot for interrupts.11: 1 solar year
  rayVenus - public array, medium priority appointment slot for interrupts.7: 1 solar year
  rayEarth - public array, lowest priority appointment slot for interrupts.4: 1 solar year
  rayMars - public array, list of all the objects to render in the next frame.

Methods:
  funBenchmark() - determines a stable interval in milliseconds
  for the users computer to run the game loop
  funStartLoop() - initiates the game loop
  funStopLoop() - ends the game loop
  funTurnCircle() - set game loop intensity in milliseconds manually
  funRedrawTheWorld - Renders one full frame by calling funRender() method of all the objects in rayMars
*/
//# OOmutiny is licensed under the BSD 3-Clause "New" or "Revised" License
//# To view a copy of this license, visit https://github.com/DanielBullimore/OOmutiny/blob/master/LICENSE
//****************************************************************************************************** 
//###############
//# PROPERTIES #
//###############

var numBenchmarkSolarYear = 0;
var threads = {
  "mars": {
    "work": new Array(),
    "numExeT": new Date(0),
    "fractal": 3
  },
  "earth": {
    "work": new Array(),
    "numExeT": new Date(0),
    "fractal": 4
  },
  "venus": {
    "work": new Array(),
    "numExeT": new Date(0),
    "fractal": 7
  },
  "mercury": {
    "work": new Array(),
    "numExeT": new Date(0),
    "fractal": 11
  },
};

//###################
//# DERIVED VALUES #
//###################
//#########################
//# CONSTRUCT DESTRUCT #
//#########################
//##############
//# FUNCTIONS #
//##############
function funStartLoop() {
  /*
  Description: initiates the game loop provided bench mark is not zero
  Parameters:
  -
  Returns: -
  */
  if (threads.mercury.numExeT === 0)
  {//Light the fires and kick the tyres
    threads.mercury.numExeT = new Date();
    threads.venus.numExeT = new Date();
    threads.earth.numExeT = new Date();
    threads.mars.numExeT = new Date();
    console.log("kicking the tyres")
  }
  /* If this machine has been benchmarked and the loop isnt puased
   * zero = no benchmark do not loop
   * positive number = benchmarked
   * negative number = puase
   */

  if (numBenchmarkSolarYear > 0)
  {
    //save the exact date in milliseconds
    var datNow = new Date();
    //iterate through the list of planet-threads stored on mars array
    for (var numPlanet in threads)
    {
      console.log("Inspecting Planet Thread Array:");
      /* by subtracting the date in ms when each thread last executed
       * from the date now in ms we can derive how many ms have passed since.
       * When ms passed is the same or higher than a threads 'day/iteration'
       * aka solar year divied by planet day length, execute that thread.]
       */
      
      var neg = threads[numPlanet].numExeT.valueOf() - datNow.valueOf()
      var test = neg - (neg + neg);

      if (test >= numBenchmarkSolarYear / threads[numPlanet].fractal && numPlanet !=="")
      { 
        console.log("This Planet Is Due")
        /* store the time in milliseconds to calculate when
         * to execute this planet thread next
         */
        threads[numPlanet].numExeT = datNow;
        /* When a planet thread has completed its day
         * iterate through that planets work Array starting
         * from the oldest interrupt.
         */
        var jobs = Object.keys(threads[numPlanet].work).length;
        var booInterrupted = false;


        while (jobs > 0) {
          console.log("Auditing Work Due...")
          //Grab the next interrupt
          var oJob = threads[numPlanet].work.shift();

          //No execution yet and this interrupt was found due.
          if (booInterrupted === false && oJob.numCycleCount >= oJob.numCycles) {
            
            //is this interrupt an Act Or Solve job?
            if (oJob.booActOrSolve) {
              //execute the Act function stored in interrupt
              
              this.t = oJob.funAct;
              this.t();
            }
            else {
              //execute the solve function stored in interrupt 
              this.t = oJob.funSolve;
              this.t();
            }
            //reset cycle count for interrupt as it just executed
            oJob.numCycleCount = 0;
            booInterrupted = true;
            console.log("Delt to first interruption on planet")
          }
/* ### POST EXECUTION ##>>>
* Check the state of this interupt
* Infinite repeating interrupts require state reset and put to back of queu
* Interrupts set to repeat finite # times require state update
  or require deletion if complete.
* All other executed interrupts require deletion
*/
              
//### Repeater not interrupted >>>
            if ((oJob.booRepeat) && (booInterrupted === false) ||
//### Non Repeater Not interrupted >>>
            (oJob.booRepeat === false) && (booInterrupted === false))
            {
              /* This interrupt isnt due, increase numCycleCount
               * to show another cycle has passed it with out execution
               */
              oJob.numCycleCount++;
            }
            else if ((booInterrupted === true)&&( oJob.numExecutions === 0))
//### Interrupted Infinite Repeater >>>
            {
              //already cycle zero ^^^up there around line 199, just refresh
              threads[numPlanet].work.push(oJob);
            }
//### Interruped Finite Repeater >>>
            else if ((booInterrupted === true)&&( oJob.numExecutions > 1))
            {
              // refresh and plus cycle 
              oJob.numCycleCount++;
              threads[numPlanet].work.push(oJob);
             
            }
//### Any Other Interrupts Else Dies >>
            //just dont push oJob back on the planet array and it will die
            //do the next job
            jobs--;
            console.log("Cleaning for")
        }
      }
/*#### Plants interrupts Updated ^^^
 >>>Now do some accounting. Machines measure timing in a frequency
 of electon pulses in hz (Ghz,Mhz,Hz). This software measures
 time in milliseconds. It is posible that a fast cpu could execute 
 more than one interupt per millisecond.
* Determine if another thread executed this millisecond
* add another collision.
*/
      if (booInterrupted === true)
      {
        for (var strPlanet in threads)
        {
          if (threads[numPlanet].numExeT.valueOf() == threads[strPlanet].numExeT.valueOf())
          {
            collisions++;
            console.log("accounting collisions");
          }
        }
      }
    }
//### Benched + Plants arrays done >>>
  }
  /* This method has been called while loop was on pause
   * inverse the benchmark to unpuase
   */
  else if (numBenchmarkSolarYear < 0) {
    numBenchmarkSolarYear -= numBenchmarkSolarYear + numBenchmarkSolarYear
  }
  window.setTimeout(funStartLoop , 1);
  console.log("LOOP!")
}

function funStopLoop()
/* Description: 
    ends execution of game loop 
* Parameters: - 

* Returns: -
*/
{
  /*inverse the benchmark so its negative value ends execution 
   * but retains the value (to restart with out a new bench) 
   */
  numBenchmarkSolarYear -= numBenchmarkSolarYear + numBenchmarkSolarYear;

}

function funBenchmark() {
  /* Description: 
      calculate how intense a loop the cliet machine can run well
      measure how long it takes to plot a 1000 value vector matrix
  * Parameters: - 
  
  * Returns: -
  */
  //if (executions < 10000) {
  //Beanch Mark 
  if(confirm("I will now benchmark your browser."))
  {
    if (numBenchmarkSolarYear === 0)
    {
      
      var a = new Date();
      //dom in a transperent canvas
      document.getElementById("bencher").width=1000;
      document.getElementById("bencher").height=1000;
      //color 1000/1000 px grid one px at a time ether black or white based on random 1|0
      //what size is the screen
      for (x = 0; x<100; x+=10)
      {
        for(y = 0; y<10; y+=1)
        {
          var oLineThread = new o();
          oLineThread.numCycles = 1;
          oLineThread.booActOrSolve = true;
          oLineThread.booRepeat = false;
          oLineThread.numExecutions = 1;
          oLineThread.x = x;
          oLineThread.y = y;
          oLineThread.funAct = function()
          {
            var elbencher = document.getElementById("bencher");
            var bencher = elbencher.getContext("2d");
            if (Math.random() === 1)
            {
              bencher.strokeStyle = "#ffffff";
            }
            else
            {
              bencher.strokeStyle = "#000000";
            }
            //paint line at A=(x,y)B=(x,y)
            bencher.moveTo(this.x, this.y);
            bencher.lineTo(1000-this.x, 100*this.y^3);//widthOFScreen-x, (widthOfScreen/10)*y^3
            bencher.stroke();
          };
          console.log("oLine:("+x+","+y+")");
          threads.mercury.work.push(oLineThread);
          
        }
      }
      //alert (threads.mercury.work.join());
      var b = new Date();
      var c = (b - a);
      //document.getElementById("bencher").width = 0;
      //document.getElementById("bencher").height = 0;
      numBenchmarkSolarYear = 1000; //c.valueOf();
      funStartLoop();
      console.log("Be Starting UP The Loop");
    }  
  }
}
