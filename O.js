//Javascript Document
//Copyright 2019 Daniel Bullimore
//* File Name: O.class.js
//* System: OOmutiny
//* Dependencies: <Name any files this one requires to operate correctly>
//****************************************************************************************************** 	
//* Author:        Daniel Bullimore
//* Authors email: daniel.k.bullimore@gmail.com
//* Written:       31/12/2019
//******************************************************************************************************
//* !---If you modify this file, add your name to this then update the Last Modified date---!
//* Modifications By: <name1>, <name2>, â€¦ , <Your Name>
//* Last Modified:      <Date dd/mm/yyyy>
//******************************************************************************************************
//*
//*
//******************************************************************************************************
//* DESCRIPTION
//******************************************************************************************************
/*
Stable Loop, executes queued interrupts between drawing the "world".
Drawing the world involves redrawing all the rendered objects to synchronize their GUI state with their
programmatic states. Interrupts are generated by events and are intended to ether act(small immediate
animations) or solve(change a instances properties). I envision the loop + interrupt relationship 
working like an appointment book, except the book is kept by the sun at the center of a solar system.

*That suns line of sight is static

*The sun only sees interrupts by appointment, but they must be on time

*Each page of an appoint book is normally divided into denominated appointment slots.For our sun those
slots are its planets

*More than one Interrupt can queue on a single planet appointment slot

*Interrupts can not queue on the planet furthest from the sun, that slot draws the world

*The planets distances from the sun is determined by a benchmark run before the sun ever existed

*Each time a planet crosses the suns line of sight, the sun executes one interrupt.

*A solar year ends when the most distant planet crosses the suns line of sight it redraws the world(one frame)

As a result the sun can now deal with one off interrupts on a priority basses.A four planet solar system
  will see its closest planet 4 times before it sees its most distant planet once(complete iteration of the
  stable loop).Highest priority interrupts go on the closest planet and lower priority on more distant ones.
  As a cool side effect an HID interrupt on planet 1 might set an interrupt on planet 2 which could be 
  executed before the solar year ends.It also allows 3 intensity settings  for high frequency repeating interrupts.

So what I 'm trying to do here is remove the time in exact milliseconds
  from the framework. The number of milliseconds each iteration of the game
  loop takes is dynamic per machine it benchmarks. So developers 
  implementing my OoMutiny framework couldn't book an interrupt in 67 
  milliseconds if a benchmark determined a 1000 millisecond loop because it
  wouldn 't ever be executed. However if we benchmark two machines A and B.
  A scored 1000ms solar year (complete loop, 1 frame), B scored 400ms. 
  Then we divide those scores by three to get the first planets cycles per
  solar year, divide by 4 to get planet 2, 7 for planet 3...
  Thus our developers can book an interrupt in "Cycles"
  on both machines confident that it will be executed in a timely and 
  graceful fashion regardless of an individual client machines computing power.
  Real time can be derived in a Cycles per second benchmark.
  
This one system quickly provides:

  *Prioritization of immediate interrupts
  *Intensity of high frequency interrupts
  *scaled time critical interrupts over multi solar year runs
  *Performance tailored to each client.

Properties:
  numBenchmarkSolarYear - Protected number, interval in milliseconds between drawing each frame.(one solar year)
  numCyclesPerSecond - private number, derived value, effectively frames per second.Used to calculate realtime.
  rayMecury - public array, highest priority appointment slot for interrupts.11: 1 solar year
  rayVenus - public array, medium priority appointment slot for interrupts.7: 1 solar year
  rayEarth - public array, lowest priority appointment slot for interrupts.4: 1 solar year
  rayMars - public array, list of all the objects to render in the next frame.

Methods:
  funBenchmark() - determines a stable interval in milliseconds
  for the users computer to run the game loop
  funStartLoop() - initiates the game loop
  funStopLoop() - ends the game loop
  funTurnCircle() - set game loop intensity in milliseconds manually
  funRedrawTheWorld - Renders one full frame by calling funRender() method of all the objects in rayMars
*/
//# OOmutiny is licensed under the BSD 3-Clause "New" or "Revised" License
//# To view a copy of this license, visit https://github.com/DanielBullimore/OOmutiny/blob/master/LICENSE
//****************************************************************************************************** 
//###############
//# PROPERTIES #
//###############

var numBenchmarkSolar;
var threads = {
  "mars": {
    "work": new Array(),
    "numExeT": new Date(),
    "fractal": 3
  },
  "earth": {
    "work": new Array(),
    "numExeT": new Date(4),
    "fractal": 11
  },
  "venus": {
    "work": new Array(),
    "numExeT": new Date(7),
    "fractal": 7
  },
  "mercury": {
    "work": new Array(),
    "numExeT": new Date(11),
    "fractal": 11
  },
};

//###################
//# DERIVED VALUES #
//###################
//#########################
//# CONSTRUCT DESTRUCT #
//#########################
//##############
//# FUNCTIONS #
//##############
function funStartLoop() {
  /*
  Description: initiates the game loop provided bench mark is not zero
  Parameters:
  -
  Returns: -
  */
  /* If this machine has been benchmarked and the loop isnt puased
   * zero = no benchmark do not loop
   * positive number = benchmarked
   * negative number = puase
   */
  document.getElementById('coor').inerHTML = ":";
  if (numBenchmarkSolarYear > 0)
  {
    //save the exact date in milliseconds

    //iterate through the list of planet-threads stored on mars array
    for (var numPlanet in threads)
    {

      /* by subtracting the date in ms when each thread last executed
       * from the date now in ms we can derive how many ms have passed since.
       * When ms passed is the same or higher than a threads 'day/iteration'
       * aka solar year divied by planet day length, execute that thread.]
       */
      var datNow = new Date();
      var neg = threads[numPlanet].numExeT.valueOf() - datNow.valueOf()
      var test = neg - (neg + neg);

      if (test >= numBenchmarkSolarYear / threads[numPlanet].fractal)
      { //degub document.getElementById('coor').innerHTML += test+":"+numBenchmarkSolarYear/threads[numPlanet].fractal+"<br>";
        threads[numPlanet].numExeT = datNow;
        /* When a planet thread has completed its day
         * iterate through that planets work Array starting
         * from the oldest interrupt.
         */
        var jobs = Object.keys(threads[numPlanet].work).length;
        var booInterrupted = false;


        while (jobs > 0) {

          //Grab the next interrupt
          var oJob = threads[numPlanet].work[jobs - 1];

          //No execution yet and this interrupt was found due.
          if (booInterrupted === false && oJob.numCycles <= oJob.numCycleCount) {
            //alert(oJob.numCycles+":"+oJob.numCycleCount);
            //is this interrupt an Act Or Solve job?
            if (oJob.booActOrSolve) {
              //execute the Act function stored in interrupt
              //alert(oJob.funAct[0]);
              this.t = oJob.funAct;
              this.t();
            }
            else {
              //execute the solve function stored in interrupt 

              this.t = oJob.funSolve;
              this.t();
            }

            booInterrupted = true;

            /* ### POST EXECUTION ##>>>
              * Check the state of this interupt
              * Infinite repeating interrupts require state reset and put to back of queu
              * Interrupts set to repeat finite # times require state update
              or require deletion if complete.
              * All other executed interrupts require deletion
              */
            if (oJob.booRepeat && oJob.numExecutions === 0)
            {
              //reset cycle count for infinite repeating interrupt
              oJob.numCycleCount = 0;
              //put to back of queu
              delete threads[numPlanet].work[jobs];
              this[numPlanet].work.unshift(oJob);
            }
            else if (oJob.booRepeat && oJob.numExecutions > 1)
            {
              //delete this finite repeating interrupt
              oJob.numExecutions--;
            }
            else
            {
              //delete this executed interrupt
              delete threads[numPlanet].work[jobs];
            }
          }
          else
          {
            /* This interrupt isnt due, increase numCycleCount
             * to show another cycle has passed it with out execution
             */
            oJob.numCycleCount++;
          }

          jobs--;

        }
      }
      //after checking exet for a thread
      /* store the time in milliseconds to calculate when
       * to execute this planet thread next
       */
      if (booInterrupted === false) {
        funCollisionDetect(numPlanet);
        //threads[numPlanet].numExeT = new Date();
        //break;
      }
    }
    //after going through the palnets array

  }
  /* This method has been called while loop was on pause
   * inverse the benchmark to unpuase
   */
  else if (numBenchmarkSolarYear < 0) {
    alert("k");
    numBenchmarkSolarYear -= numBenchmarkSolarYear + numBenchmarkSolarYear
  }

}

function funStopLoop()
/* Description: 
    ends execution of game loop 
* Parameters: - 

* Returns: -
*/
{
  /*inverse the benchmark so its negative value ends execution 
   * but retains the value (to restart with out a new bench) 
   */
  numBenchmarkSolarYear -= numBenchmarkSolarYear + numBenchmarkSolarYear;

}

function funBenchmark() {
  /* Description: 
      calculate how intense a loop the cliet machine can run well 
  * Parameters: - 
  
  * Returns: -
  */
  numBenchmarkSolarYear = 1000;

}
